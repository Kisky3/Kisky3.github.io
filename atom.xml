<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiang Yu&#39;s Blog</title>
  
  <subtitle>Hello World, Hello Programming!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kisky3.github.io/"/>
  <updated>2019-06-24T08:21:24.845Z</updated>
  <id>https://kisky3.github.io/</id>
  
  <author>
    <name>Xiang Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从URL到页面展现</title>
    <link href="https://kisky3.github.io/2018/11/10/%E4%BB%8EURL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0/"/>
    <id>https://kisky3.github.io/2018/11/10/从URL到页面展现/</id>
    <published>2018-11-10T07:54:13.000Z</published>
    <updated>2019-06-24T08:21:24.845Z</updated>
    
    <content type="html"><![CDATA[<span class="highlight-text" style="background-color:#99CCFF;">专有名词解释：URL：统一资源定位符 http : 网络协议 用于找到互联网上的资源</span><h3 id="1-在浏览器输入URL"><a href="#1-在浏览器输入URL" class="headerlink" title="1.在浏览器输入URL"></a>1.在浏览器输入URL</h3><a id="more"></a><p>通过输入「<a href="http://www.baidu.com」" target="_blank" rel="noopener">http://www.baidu.com」</a> 的URL来最终定位找到百度首页。</p><hr><h3 id="2-域名解析"><a href="#2-域名解析" class="headerlink" title="2.域名解析"></a>2.域名解析</h3><p>对于　「<a href="http://baidu.com」" target="_blank" rel="noopener">http://baidu.com」</a>　的URL来说，浏览器实际上不知道baidu.com到底是什么，需要对应查找到该域名对应的服务器IP地址才能找到目标。<br>域名解析的流程</p><p>1.浏览器缓存<br>如果你之前打开过百度首页，那么百度的ip地址会被缓存到浏览器里，当你打开时百度首页时就能从浏览器缓存里获取之前缓存的百度ip地址并访问它。</p><p>2.系统缓存<br>如果你是第一次打开百度，那么无法从浏览器获取缓存，便会从你电脑的Hosts文件查找是否有该域名和其对应ip。<br>下图为Mac电脑的hosts文件内容。开发时可以修改hosts文件内的ip，达到打开本地文件的效果。</p><img src="./1.png" width:400px><p>3.路由器缓存<br>如果浏览器缓存和系统缓存都没有，就会看你的路由器缓存。路由器曾经登陆过也会缓存域名信息，如果你或别人在该路由器上登陆过网站，则可以获取到baidu的ip地址。</p><p>4.ISPDNS缓存<br>如果路由器也没有缓存就会找你的服务商，比如到电信的DNS上查找。</p><p>5.如果都没有找到就会到你的根域名服务器查找域名对应ip，根域名服务器把请求转发到下一级，直到找到ip。(找不到就返回404 找不到服务器)</p><hr><h3 id="3-服务器处理"><a href="#3-服务器处理" class="headerlink" title="3.服务器处理"></a>3.服务器处理</h3><p>服务器是一台安装电脑的机器，常见的系统如Linux，Windows Server 系统里安装的处理请求的应用叫做Web Server。<br>常见的Web服务器有Apache，Nginx，IIS，Lighttpd等。Web服务器接收用户的Request交给网站代码，或者接受请求反向代理到其他Web服务器。也就是一个管理者的作用。<br>下图的白色区域为Web服务器。</p><img src="./2.png" width:400px><hr><h3 id="4-网站处理流程"><a href="#4-网站处理流程" class="headerlink" title="4.网站处理流程"></a>4.网站处理流程</h3><p>经服务器处理后，网站接受请求后进行处理，最后将页面呈现给用户。<br>比如下图的MVC模型</p><img src="./3.png" width:400px><hr><h3 id="5-浏览器读取并再次请求"><a href="#5-浏览器读取并再次请求" class="headerlink" title="5.浏览器读取并再次请求"></a>5.浏览器读取并再次请求</h3><p>HTML字符串被浏览器接受后被一句句读取解析，解析到link标签后重新发送请求获取CSS。解析到script标签后发送请求获取js，并执行代码。解析到img标签后发送请求获取图片。</p><hr><h3 id="6-浏览器渲染"><a href="#6-浏览器渲染" class="headerlink" title="6.浏览器渲染"></a>6.浏览器渲染</h3><p>浏览器根据获取到的HTML和CSS计算并渲染，绘制到屏幕上的js会被执行。<br>到此你就能看到你所打开的网页了。</p>]]></content>
    
    <summary type="html">
    
      &lt;span class=&quot;highlight-text&quot; style=&quot;background-color:#99CCFF;&quot;&gt;专有名词解释：URL：统一资源定位符 http : 网络协议 用于找到互联网上的资源&lt;/span&gt;
&lt;h3 id=&quot;1-在浏览器输入URL&quot;&gt;&lt;a href=&quot;#1-在浏览器输入URL&quot; class=&quot;headerlink&quot; title=&quot;1.在浏览器输入URL&quot;&gt;&lt;/a&gt;1.在浏览器输入URL&lt;/h3&gt;
    
    </summary>
    
      <category term="Front-end Knowledge" scheme="https://kisky3.github.io/categories/Front-end-Knowledge/"/>
    
    
      <category term="URL" scheme="https://kisky3.github.io/tags/URL/"/>
    
  </entry>
  
  <entry>
    <title>常见浏览器及浏览器内核</title>
    <link href="https://kisky3.github.io/2018/10/29/%E5%B8%B8%E8%A7%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/"/>
    <id>https://kisky3.github.io/2018/10/29/常见浏览器及浏览器内核/</id>
    <published>2018-10-29T10:42:04.000Z</published>
    <updated>2019-06-24T07:49:55.491Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器内核可以分为：渲染引擎(layout engineer)和JS引擎。</p><a id="more"></a><p>它负责：</p><ul><li>获取网页的HTML，XML，图像等内容</li><li>整理CSS讯息以及计算机网页的显示方式</li><li>然后会输出至显示器或打印机。</li></ul><h3 id="内核是什么"><a href="#内核是什么" class="headerlink" title="内核是什么"></a>内核是什么</h3><p>浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。<br>所有的网页浏览器，电子邮件客户端以及其他需要编辑显示网络内容的应用程序都需要内核。JS引擎是解析Javascript语言，执行javascript语言来实现网页的动态效果。</p><p>最开始渲染引擎和JS引擎并没有很明确的区分，后来JS引擎越来越独立，内核就只倾向于只指渲染引擎。</p><hr><h3 id="内核的种类"><a href="#内核的种类" class="headerlink" title="内核的种类"></a>内核的种类</h3><p>内核的种类有很多，加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分为以下四种：</p><span class="highlight-text" style="background-color:#FFCCCC;">Trident，Gecko，Blink，Webkit。</span><h4 id="Trident-‘traɪd-ə-nt"><a href="#Trident-‘traɪd-ə-nt" class="headerlink" title="Trident ([‘traɪd(ə)nt])"></a>Trident ([‘traɪd(ə)nt])</h4><p>Trident(IE内核)：该内核程序在 1997 年的 IE4 中首次被采用，是微软在 Mosaic（”马赛克”，这是人类历史上第一个浏览器，从此网页可以在图形界面的窗口浏览） 代码的基础之上修改而来的，并沿用到 IE11，也被普遍称作 “IE内核”。</p><p>Trident实际上是一款开放的内核，其接口内核设计的相当成熟，因此才有许多采用 IE 内核而非 IE 的浏览器(壳浏览器)涌现。由于 IE 本身的 “垄断性”（虽然名义上 IE 并非垄断，但实际上，特别是从 Windows 95 年代一直到 XP 初期，就市场占有率来说 IE 的确借助 Windows 的东风处于 “垄断” 的地位）而使得 Trident 内核的长期一家独大，微软很长时间都并没有更新 Trident 内核，这导致了两个后果——</p><p>一是 Trident 内核曾经几乎与 W3C 标准脱节（2005年），二是 Trident 内核的大量 Bug 等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为 IE 浏览器不安全的观点，也有很多用户转向了其他浏览器，Firefox 和 Opera 就是这个时候兴起的。非 Trident 内核浏览器的市场占有率大幅提高也致使许多网页开发人员开始注意网页标准和非 IE浏览器的浏览效果问题。</p><p>补充：IE 从版本 11 开始，初步支持 WebGL 技术。IE8 的 JavaScript 引擎是 Jscript，IE9 开始用 Chakra，这两个版本区别很大，Chakra 无论是速度和标准化方面都很出色。<br>国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。<br>Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。<br>关于 Edge 浏览器更多可以参考 如何评价 Microsoft Edge 浏览器</p><h4 id="Gecko-‘gekəʊ"><a href="#Gecko-‘gekəʊ" class="headerlink" title="Gecko ([‘gekəʊ])"></a>Gecko ([‘gekəʊ])</h4><p>Gecko(Firefox 内核)：Netscape6 开始采用的内核，后来的 Mozilla FireFox(火狐浏览器) 也采用了该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko 内核的浏览器也很多，这也是 Gecko 内核虽然年轻但市场占有率能够迅速提高的重要原因。</p><p>事实上，Gecko 引擎的由来跟 IE 不无关系，前面说过 IE 没有使用 W3C 的标准，这导致了微软内部一些开发人员的不满；他们与当时已经停止更新了的 Netscape 的一些员工一起创办了 Mozilla，以当时的 Mosaic 内核为基础重新编写内核，于是开发出了 Gecko。不过事实上，Gecko 内核的浏览器仍然还是 Firefox (火狐) 用户最多，所以有时也会被称为 Firefox 内核。此外 Gecko 也是一个跨平台内核，可以在Windows、 BSD、Linux 和 Mac OS X 中使用。</p><h4 id="Webkit"><a href="#Webkit" class="headerlink" title="Webkit"></a>Webkit</h4><p>一提到 webkit，首先想到的便是 chrome，可以说，chrome 将 Webkit内核 深入人心，殊不知，Webkit 的鼻祖其实是 Safari。现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了），苹果都哭瞎了有木有。</p><p>Safari 是苹果公司开发的浏览器，使用了KDE（Linux桌面系统）的 KHTML 作为浏览器的内核，Safari 所用浏览器内核的名称是大名鼎鼎的 WebKit。 Safari 在 2003 年 1 月 7 日首度发行测试版，并成为 Mac OS X v10.3 与之后版本的默认浏览器，也成为苹果其它系列产品的指定浏览器（也已支持 Windows 平台）。</p><p>如上述可知，WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。当年苹果在比较了 Gecko 和 KHTML 后，选择了后者来做引擎开发，是因为 KHTML 拥有清晰的源码结构和极快的渲染速度。</p><p>Webkit内核 可以说是以硬件盈利为主的苹果公司给软件行业的最大贡献之一。随后，2008 年谷歌公司发布 chrome 浏览器，采用的 chromium 内核便 fork 了 Webkit。</p><h4 id="Chromium-Blink"><a href="#Chromium-Blink" class="headerlink" title="Chromium/Blink"></a>Chromium/Blink</h4><p>2008 年，谷歌公司发布了 chrome 浏览器，浏览器使用的内核被命名为 chromium。</p><p>chromium fork 自开源引擎 webkit，却把 WebKit 的代码梳理得可读性提高很多，所以以前可能需要一天进行编译的代码，现在只要两个小时就能搞定。因此 Chromium 引擎和其它基于 WebKit 的引擎所渲染页面的效果也是有出入的。所以有些地方会把 chromium 引擎和 webkit 区分开来单独介绍，而有的文章把 chromium 归入 webkit 引擎中，都是有一定道理的。</p><p>谷歌公司还研发了自己的 Javascript 引擎，V8，极大地提高了 Javascript 的运算速度。</p><p>chromium 问世后，带动了国产浏览器行业的发展。一些基于 chromium 的单核，双核浏览器如雨后春笋般拔地而起，例如 搜狗、360、QQ浏览器等等，无一不是套着不同的外壳用着相同的内核。</p><p>然而 2013 年 4 月 3 日，谷歌在 Chromium Blog 上发表 博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。</p><p>webkit 用的好好的，为何要投入到一个新的内核中去呢？</p><p>Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支。Google 的 Chromium 项目此前一直使用 WebKit(WebCore) 作为渲染引擎，但出于某种原因，并没有将其多进程架构移植入Webkit。</p><p>后来，由于苹果推出的 WebKit2 与 Chromium 的沙箱设计存在冲突，所以 Chromium 一直停留在 WebKit，并使用移植的方式来实现和主线 WebKit2 的对接。这增加了 Chromium 的复杂性，且在一定程度上影响了 Chromium 的架构移植工作。</p><p>基于以上原因，Google 决定从 WebKit 衍生出自己的 Blink 引擎（后由 Google 和 Opera Software 共同研发），将在 WebKit 代码的基础上研发更加快速和简约的渲染引擎，并逐步脱离 WebKit 的影响，创造一个完全独立的 Blink 引擎。这样以来，唯一一条维系 Google 和苹果之间技术关系的纽带就这样被切断了。</p><p>Google 和苹果在多个领域都是竞争对手，而唯独在浏览器引擎上有技术合作，利益一致。但为了各自的利益，谁都不会拿出 100% 的 “诚意” 来做好 WebKit，因为你做出来的成果竞争对手可以直接享用。移动互联网已经崛起，手机和平板设备端必将成为浏览器的另一个战场。这个时候，如果 Google 跟苹果仍然黏在一起，将会严重阻碍双方的进步，也会阻碍 WebKit 的进步。</p><h4 id="Presto-‘prestəʊ"><a href="#Presto-‘prestəʊ" class="headerlink" title="Presto ([‘prestəʊ])"></a>Presto ([‘prestəʊ])</h4><p>Presto 是挪威产浏览器 opera 的 “前任” 内核，为何说是 “前任”，因为最新的 opera 浏览器早已将之抛弃从而投入到了谷歌大本营。</p><p>Opera 的一个里程碑作品是 Opera7.0，因为它使用了 Opera Software 自主开发的 Presto 渲染引擎，取代了旧版 Opera 4 至 6 版本使用的 Elektra 排版引擎。该款引擎的特点就是渲染速度的优化达到了极致，然而代价是牺牲了网页的兼容性。</p><p>Presto 加入了动态功能，例如网页或其部分可随着 DOM 及 Script 语法的事件而重新排版。Presto 在推出后不断有更新版本推出，使不少错误得以修正，以及阅读 Javascript 效能得以最佳化，并成为当时速度最快的引擎。</p><p>然而为了减少研发成本，Opera 在 2013 年 2 月宣布放弃 Presto，转而跟随 Chrome 使用 WebKit 分支的 Chromium 引擎作为自家浏览器核心引擎，Presto 内核的 Opera 浏览器版本永远的停留在了 12.17。在 Chrome 于 2013 年推出 Blink 引擎之后，Opera 也紧跟其脚步表示将转而使用 Blink 作为浏览器核心引擎。</p><p>Presto 与开源的 WebKit 和经过谷歌加持的 Chromium 系列相比毫无推广上的优势，这是 Opera 转投 WebKit 的主要原因，并且使用 WebKit 内核的 Opera 浏览器可以兼容谷歌 Chrome 浏览器海量的插件资源。但是换内核的代价对于 Opera 来说过于惨痛。使用谷歌的 WebKit 内核之后，原本快速，轻量化，稳定的 Opera 浏览器变得异常的卡顿，而且表现不稳定，Opera 原本旧内核浏览器书签同步到新内核上的工作 Opera 花了整整两年时间，期间很多 Opera 的用户纷纷转投谷歌浏览器和其他浏览器，造成了众多的用户流失。时至今日现在还有上千万人在使用老版本的 Opera。</p><p>很多人都认为 Opera 浏览器终止在了 12.17，此后所更新的 Opera 版本号不再是原来那个 Opera。</p><hr><h3 id="关于移动端"><a href="#关于移动端" class="headerlink" title="关于移动端"></a>关于移动端</h3><p>移动端的浏览器内核主要说的是系统内置浏览器的内核。</p><p>目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>浏览器内核主要指的是浏览器的渲染引擎，2013 年以前，代表有 Trident（IE），Gecko（firefox），Webkit（Safari chrome 等）以及 Presto（opera)。2013 年，谷歌开始研发 blink 引擎，chrome 28 以后开始使用，而 opera 则放弃了自主研发的 Presto 引擎，投入谷歌怀抱，和谷歌一起研发 blink 引擎，国内各种 chrome系的浏览器（360、UC、QQ、2345 等等）也纷纷放弃 webkit，投入 blink 的怀抱。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器内核可以分为：渲染引擎(layout engineer)和JS引擎。&lt;/p&gt;
    
    </summary>
    
      <category term="Front-end Knowledge" scheme="https://kisky3.github.io/categories/Front-end-Knowledge/"/>
    
    
      <category term="浏览器" scheme="https://kisky3.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="浏览器内核" scheme="https://kisky3.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Get和Post提交数据有什么区别</title>
    <link href="https://kisky3.github.io/2018/10/25/Get%E5%92%8CPost%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>https://kisky3.github.io/2018/10/25/Get和Post提交数据有什么区别/</id>
    <published>2018-10-25T07:18:03.000Z</published>
    <updated>2019-06-24T07:40:15.693Z</updated>
    
    <content type="html"><![CDATA[<span class="highlight-text" style="background-color:#FFCCCC;">1.post更安全，安全要求高的用post 要求低的用get</span><br><a id="more"></a><br><span class="highlight-text" style="background-color:#FFCCCC;">2.post发送的数据更大（get有url长度限制）</span><br><br><span class="highlight-text" style="background-color:#FFCCCC;">3.post能发送更多的数据类型</span><br><br><span class="highlight-text" style="background-color:#FFCCCC;">4.post比get慢</span><br>(原因:post在真正接收数据之前会先将请求头发送给服务器进行确认，服务器返回100 Continue响应之后才真正发送数据 )<br><br><span class="highlight-text" style="background-color:#FFCCCC;">5.post用于向后台传数据，get一般用于向后台要数据。</span>]]></content>
    
    <summary type="html">
    
      &lt;span class=&quot;highlight-text&quot; style=&quot;background-color:#FFCCCC;&quot;&gt;1.post更安全，安全要求高的用post 要求低的用get&lt;/span&gt;
&lt;br&gt;
    
    </summary>
    
      <category term="Front-end Knowledge" scheme="https://kisky3.github.io/categories/Front-end-Knowledge/"/>
    
    
      <category term="Get" scheme="https://kisky3.github.io/tags/Get/"/>
    
      <category term="Post" scheme="https://kisky3.github.io/tags/Post/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击及防范措施</title>
    <link href="https://kisky3.github.io/2018/10/14/CSRF%E6%94%BB%E5%87%BB%E5%8F%8A%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD/"/>
    <id>https://kisky3.github.io/2018/10/14/CSRF攻击及防范措施/</id>
    <published>2018-10-14T04:58:15.000Z</published>
    <updated>2019-06-24T07:13:01.364Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CSRF是什么"><a href="#CSRF是什么" class="headerlink" title="CSRF是什么"></a>CSRF是什么</h3><p>CSRF全称为跨站请求伪造（Cross-site request forgery），</p><a id="more"></a><p>是一种网络攻击方式，也被称为 one-click attack 或者 session riding。<br>简单说来就是已经利用登陆成功的User强制实行某些操作的恶意攻击行为。</p><hr><h3 id="CSRF攻击原理"><a href="#CSRF攻击原理" class="headerlink" title="CSRF攻击原理"></a>CSRF攻击原理</h3><p>其原理是攻击者构造网站后台某个功能接口的请求地址，诱导用户去点击或者用特殊方法让该请求地址自动加载。<br>用户在登录状态下这个请求被服务端接收后会被误以为是用户合法的操作。对于 GET 形式的接口地址可轻易被攻击，<br>对于 POST 形式的接口地址也不是百分百安全，攻击者可诱导用户进入带 Form 表单可用POST方式提交参数的页面。<br><img src="./1.png" width:400px></p><p>角色：</p><ul><li>正常浏览网页的用户： User</li><li>正规的但是具有漏洞的网站： WebA</li><li>利用CSRF进行攻击百度网站： WebB</li></ul><p>例子：<br>比如有shop.example.com这样一个购物网站，用户通过用户名和密码可以登录。其中有点击按钮重设密码的功能。<br>当用户点击按钮更改密码时，下图的送信请求将会被提交至WebA的服务器</p><p>URL：</p><ol><li><a href="http://shop.example.com/password/change" target="_blank" rel="noopener">http://shop.example.com/password/change</a></li><li>Parmeter:</li><li>new_pass:XXXXX</li><li>new_pass_conf:XXXXX</li></ol><p>说明：<br>1.User正常登陆网页WebA，WebA通过用户的认证并在User的浏览器中产生Cookie(证明是User本人登陆)</p><p>2.攻击者伪造能发送同样请求的网站WebB。利用简单的Javascript便可达到目的。</p><p>3.攻击者把该伪造的网站的URL放到img的src里上传，当User登陆后，打开网页时便会自动加载图片，WebB会利用用户的浏览器访问WebA。<br>由于User是在登录状态下，所以User的浏览器根据WebB的要求，带着1中生成的Cookie访问WebA。</p><p>4.WebA接收到User浏览器的请求，并带着用户的Cookie(如例子中的请求)，要求修改密码。</p><p>5.WebA误以为是用户的操作，响应修改密码的请求。User密码被盗。</p><p>以上Web便达到了在用户不知情的情况下，利用用户登陆后的Cookie进行用户的模拟操作过程。</p><hr><h3 id="CSRF防范措施"><a href="#CSRF防范措施" class="headerlink" title="CSRF防范措施"></a>CSRF防范措施</h3><p>1.服务端在收到路由请求时，生成一个随机数，在渲染请求页面时把随机数埋入页面<br>（一般埋入 form 表单内，）</p><p>2.服务端设置setCookie，把该随机数作为session种入用户浏览器。<br>(加入保存在Cookie中，旧Token消耗后，新的Token会被生成，造成用户混乱。而Session能避免此问题。)</p><p>3.当用户发送 GET 或者 POST 请求时带上_csrf_token参数<br>（对于 Form 表单直接提交即可，因为会自动把当前表单内所有的 input 提交给后台，包括_csrf_token）</p><p>4.后台在接受到请求后解析请求的cookie获取_csrf_token的值，然后和用户请求提交的_csrf_token做个比较，如果相等表示请求是合法的。</p><p>（下图是某电商网站的真实设置，这里页面上设置的 token和session里设置的token 虽然不直接相等，但 md5(‘1474357164624’) === ‘4bd4e512b0fbd9357150649adadedd4e’，后台还是很好计算的）</p><img src="./2.png" width:400px><img src="./3.png" width:400px><p>注意：尽量避免使用Get。因为能在发送请求时能在URL处暴露token信息。</p><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a>;</li><li><a href="https://www.jianshu.com/p/00fa457f6d3e" target="_blank" rel="noopener">CSRF攻击原理及防护</a>;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CSRF是什么&quot;&gt;&lt;a href=&quot;#CSRF是什么&quot; class=&quot;headerlink&quot; title=&quot;CSRF是什么&quot;&gt;&lt;/a&gt;CSRF是什么&lt;/h3&gt;&lt;p&gt;CSRF全称为跨站请求伪造（Cross-site request forgery），&lt;/p&gt;
    
    </summary>
    
      <category term="Back-end Knowledge" scheme="https://kisky3.github.io/categories/Back-end-Knowledge/"/>
    
    
      <category term="CSRF" scheme="https://kisky3.github.io/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>Hey,I&#39;m Xiang Yu. Welcome To My Blog</title>
    <link href="https://kisky3.github.io/2018/06/23/FirstBlog/"/>
    <id>https://kisky3.github.io/2018/06/23/FirstBlog/</id>
    <published>2018-06-23T13:14:53.000Z</published>
    <updated>2019-06-24T07:51:48.849Z</updated>
    
    <content type="html"><![CDATA[<p>你好，我是向宇！我今后的目标是成为会两门外语的高级前端开发工程师。<br>欢迎来到我的博客。我将在这里记录有关编程学习的知识，并不断更新完善这个博客。<br>谢谢你的观看与支持。欢迎你的意见与建议。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你好，我是向宇！我今后的目标是成为会两门外语的高级前端开发工程师。&lt;br&gt;欢迎来到我的博客。我将在这里记录有关编程学习的知识，并不断更新完善这个博客。&lt;br&gt;谢谢你的观看与支持。欢迎你的意见与建议。&lt;/p&gt;
    
    </summary>
    
      <category term="About Me" scheme="https://kisky3.github.io/categories/About-Me/"/>
    
    
  </entry>
  
</feed>
